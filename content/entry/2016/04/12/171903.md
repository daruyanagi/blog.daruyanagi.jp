
+++
date = "2016-04-12 17:19:03 +0000 UTC"
draft = false
title = "UWP：ユーザーコントロールを作ってみる"
tags = ["UWP","Windows開発"]

+++


{{< figure src="/images/20160412165802.png"  >}}

回作るのは、文字数カウンター付きのテキストボックス。まずはユーザーインターフェイス。
```xml

    x:Class="Hateboo.UserControls.TextBoxWithCounter"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:Hateboo.UserControls"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    d:DesignHeight="300"
    d:DesignWidth="400">

    <stackpanel></stackpanel>
        x:Name="textBox" TextChanged="textBox_TextChanged" />

        Orientation="Horizontal" HorizontalAlignment="Right">
            x:Name="textBlockCurrent">0
            <textblock></textblock>/
            x:Name="textBlockMax">0
        
    


```単にテキストボックスとカウンターラベル（0/100 みたいな表示）を配置しただけ。（コードを張り付けてから気づいたが、0/100 の / を表示するためだけに TextBlock 使ってるのはアレだな。Run とか使えばよかった）このコントロールにほしいプロパティは、

<ul>
<li>Text：TextBox の内容</li>
<li>Current：現在の TextBox 文字数</li>
<li>Max：TextBox に入力できる最大の文字数。これをオーバーすると、ラベルが赤くなる</li>
</ul>ぐらいかな。名前がいまいちなのは気にしないでくれ（Max は Limit とかのほうがよさげやな。英語わからんから知らんけど）。というわけで、こいつらを**依存関係プロパティ**として実装する。依存関係プロパティというのはいまだによくわからんが、バインディングがいい感じに動くように **CLR プロパティ**（フツーの C# のプロパティ）をクラスに登録しておく仕組みって感じだろうか。基本的にはこんな感じ。
```cs
// 依存関係プロパティ
public static readonly DependencyProperty MaxProperty = DependencyProperty.Register(
    "Max",　// Max という名前の……
    typeof(int),　// int 型の CLR プロパティを……
    typeof(TextBoxWithCounter), // クラスに登録するやで―
new PropertyMetadata(0));

// CLR プロパティ
public int Max
{
    get { return (int)GetValue(MaxProperty); }
    set
    {
        SetValue(MaxProperty, value);
        textBlockMax.Text = value.ToString();
    }
}

```だいたいはこれでいいのだけど、今回の Text プロパティだけは値が変わったときにいろいろごちゃごちゃしなきゃいけないので、コールバックを設定する。
```cs
public static readonly DependencyProperty TextProperty = DependencyProperty.Register(
    "Text",
    typeof(string),
    typeof(TextBoxWithCounter),
    // コールバックの追加
    new PropertyMetadata(string.Empty, new PropertyChangedCallback(TextPropertyChanged))
);

private static void TextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    var self = d as TextBoxWithCounter;
    var value = e.NewValue as string;

    // テキストボックスとラベルの値を更新しとく
    self.textBox.Text = value;
    self.Current = value.Length;

    // アカんときはアカくする
    if (self.Current > self.Max)
    {
        self.IsOverflow = true;
        self.textBlockCurrent.Foreground = new SolidColorBrush(Colors.Red);
    }
    else
    {
        self.IsOverflow = false;
        self.textBlockCurrent.Foreground = （デフォのブラシ）;
    }
}

```かずきさんのおかげで、案外簡単に実装できた……WPF と UWP の違いでちょっとハマったけど。<iframe src="http://blog.okazuki.jp/embed/2014/09/08/203943" title="WPF4.5入門 その53 「ユーザーコントロール」 - かずきのBlog@hatena" class="embed-card embed-blogcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;"></iframe>


