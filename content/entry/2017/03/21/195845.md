
+++
date = "2017-03-21 19:58:45 +0000 UTC"
draft = false
title = "WPF ＋ PhantomJS で Web ページの内容を取得してみる"
tags = ["C#","JavaScript"]

+++
「AngularJS で作られた Web サイトの内容がとれないよ……」って Twitter で泣いてたら、@nakaji 先生が「PhantomJS 使えばええやろ」的なことを言っていた気がするので、ちょっと試してみました。

<div class="section">
    ### PhantomJS とは
    ぶっちゃけあんまりよくわかってないのですが、_“Google Chrome のユーザーインターフェイスがない<a href="#f-32b25991" name="fn-32b25991" title="ヘッドレスっていうらしい">*1</a>やつ”_だと思えばだいたい合ってるみたいです。JavaScript で動的にデータをとってくるタイプの Web サイトの DOM をわちゃわちゃしたり、スクリーンショットをとって保存したり、ユーザーインターフェイスの操作を自動化してテストしたり……みたいな感じに使えるっぽいですね。

<ul>
<li><a href="http://phantomjs.org/">http://phantomjs.org/</a></li>
</ul>スタンドアロンのバイナリになっているので、C# からはそれを叩いて、あらかじめ用意しておいたスクリプトを処理してもらう感じになるようです。なので、任意のプロセスを叩けない UWP で使うのは難しそうですね。今回は WPF でサンプルを作りましたが、WPF 要素は皆無です。

</div>
<div class="section">
    ### 使い方
    まず NuGet で PhantomJS をとってきます。{{< figure src="/images/20170321192456.png"  >}}すると phantomjs.exe というのがソリューションに追加されます。これはコンパイル時に出力フォルダーにコピーされます。{{< figure src="/images/20170321193813.png"  >}}次に、JavaScript を用意します。今回はソリューションフォルダーのルートに Hello.js を作成。
```javascript
console.log(&#39;Hello, world!&#39;);
phantom.exit();

```最初なので、動作確認をするだけです。これも phantomjs.exe と同様、コンパイル時に出力フォルダーへコピーされるようにしておけばいいと思います。次は、これを呼ぶための C# コードを書きます。標準出力でやり取りする感じにしてみました。
```cs
public MainWindow()
{
    InitializeComponent();

    Loaded += MainWindow_Loaded;
}

private void MainWindow_Loaded(object sender, RoutedEventArgs e)
{
    var result = ProcessScript("hello.js");

    System.Diagnostics.Debug.WriteLine(result);
}

private string ProcessScript(string script, params string[] args)
{
    using (var process = new System.Diagnostics.Process())
    {
        process.StartInfo.CreateNoWindow = true;
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.RedirectStandardInput = false;
        process.StartInfo.FileName = "phantomjs.exe";
        process.StartInfo.Arguments = $"{script} {string.Join(" ", args)}";

        process.Start();
        var result = process.StandardOutput.ReadToEnd();
        process.WaitForExit();

        System.Diagnostics.Debug.WriteLine($"ProcessScript() -> Code {process.ExitCode}: {process.ExitTime - process.StartTime} has elapsed.");

        return result;
    }
}

```本当はパスの管理とかもう少し何とかしないとだめかもしれませんけど、まぁ、いいや。とりあえず、実行してみましょう。{{< figure src="/images/20170321194934.png"  >}}<br/>

```ps1
> ProcessScript() -> Code 0: 00:00:01.7818442 has elapsed.
> Hello, world!

```いい感じになってる気がします。今度はちょっと複雑にしてみます。といっても、a.href の値を配列で受け取るだけです。
```cs
// MainWindow.cs

private void MainWindow_Loaded(object sender, RoutedEventArgs e)
{
    var result = ProcessScript("hello.js", "なんか URL");

    System.Diagnostics.Debug.WriteLine(result);
}

``````javascript
// hello.js

var system = require(&#39;system&#39;);

// 引数のチェック
switch(system.args.length) {
    case 2:
        var url = system.args[1];
        break;
    default:
        console.log(&#39;error: invalid argument&#39;);
        phantom.exit(1);
        break;
}

var page = require(&#39;webpage&#39;).create();

// Web Page を開く
page.open(url, function (status) {
    switch (status) {
        case &#39;success&#39;:
            var links = page.evaluate(function () {
                return [].map.call(document.querySelectorAll(&#39;a&#39;), function (link) { return link.getAttribute(&#39;href&#39;); });
            });
            console.log(JSON.stringify(links));
            phantom.exit(0);
            break;
        default:
            console.log(&#39;error: page.open() &#39; + status);
            phantom.exit(1);
            break;
    }
});

```{{< figure src="/images/20170321195239.png"  >}}とりあえず動いている気がします。JavaScript がよくわからないのが困ったちゃんですが、まぁ、おいおいマスターしていけばいいよね。これでいろんなことに使える気がしてきました。

</div><div class="footnote">
<a href="#fn-32b25991" name="f-32b25991" class="footnote-number">*1</a><span class="footnote-delimiter">:</span><span class="footnote-text">ヘッドレスっていうらしい</span>
</div>

