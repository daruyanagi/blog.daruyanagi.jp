
+++
date = "2012-08-31 03:17:30 +0000 UTC"
draft = false
title = "SignalR Deep Dive ! に参加してきた＋WebMatrix で SignalR 動かしてみた"
tags = ["WebMatrix"]

+++
{{< figure src="/images/20120830191311.jpg"  >}}仕事を少し早くあがって、 @shibayan のリサイタルに参加してきました。最近ずっと眠れなくて、仕事中もずっと眠い状態だったけれど、結構面白かったので寝落ちせずにすんだよ（ぉ<iframe width="480" height="296" src="http://www.ustream.tv/embed/recorded/25059062?wmode=direct" scrolling="no" frameborder="0" style="border: 0px none transparent;">    </iframe><br/>
<br/><a href="http://www.ustream.tv/" style="padding: 2px 0px 4px; width: 400px; background: #ffffff; display: block; color: #000000; font-weight: normal; font-size: 10px; text-decoration: underline; text-align: center;" target="_blank">Video streaming by Ustream</a>興味ある人は USTREAM をご覧あれ。わしもよくわからんけど、とりあえず SignalR （<a href="http://signalr.net/">http://signalr.net/</a>）というのは、

<ul>
<li>ASP.NET テクノロジをベースとした</li>
<li>非同期でリアルタイムな</li>
<li>サーバーとクライアントの双方向通信</li>
</ul>を実現するライブラリ、ってことでいいのかな。サーバーとクライアントの通信で利用される技術は、 SignalR が勝手にチョイスしてくれるみたい（モダンな環境なら WebSocket を、クラシカルな環境だったらポーリングを、ってな感じ）。詳しくはエロいひと、じゃなくて偉いひとに聞いて欲しい。ともあれ、忘れないうちにこれを WebMatrix で使ってみる。

<div class="section">
    ### サーバー側のコード
    ```cs
# ~/App_Code/SampleHub.cs

using SignalR.Hubs; // &lt;-- NuGet でインストールしる！

[HubName("sample")] // &lt;-- あとで createProxy("sample") と使う
public class SampleHub : Hub
{
    private static string _message = "";

    private string Message
    {
        get { return _message; }
        set
        {
            _message = value;

            // 接続中のクライアントすべてに Echo() 命令を送る
            Clients.Echo(_message);

            // そのほかにも
            // Caller.Echo(); 呼び出したクライアントに命令
            // Groups["Hoge"].Echo(); クライアントグループに命令
            // がある
        }
    }

    public void Add(string s)// &lt;-- ちゃんと公開しろよ
    {
        Message += s;
    }

    public void Clear()
    {
        Message = "";
    }
}

```まずは、 Hub というものを作る。今回は文字列（Message）を足す関数（Add）と、クリアする関数（Clear）を用意した。文字列が更新されるとクライアントにその結果を表示するように命令（Echo）する。これがサーバー側の処理。

</div>
<div class="section">
    ### クライアント側のコード
    ```html
# Default.cshtml



@{
    
}

&lt;html lang="ja">
    &lt;head>
        &lt;meta charset="utf-8" />
        &lt;title>マイ サイトのタイトル&lt;/title>
        &lt;script type="text/javascript"
                src="Scripts/jquery-1.6.4.js">&lt;/script>
        &lt;script type="text/javascript"
                src="Scripts/jquery.signalR-0.5.3.js">&lt;/script>
        &lt;script>
            // 接続を取得
            var connection = $.hubConnection();

            // sample ハブ（のプロキシ）を取得
            var sample = connection.createProxy("sample");

            // 接続開始（忘れたらしばやんみたいにエラー出るで）
            connection.start();

            // sample ハブの Echo() 命令を受け取ったら……
            sample.on("Echo", function (value) {
                $("#value").html(value);
            });
        &lt;/script>
    &lt;/head>
    &lt;body>
        &lt;p id="value">&lt;/p>
        &lt;input type="button"
               onclick="sample.invoke(&#39;Add&#39;, &#39;foobar&#39;);"
               id="add" name="add" value="add" />
        &lt;input type="button"
               onclick="sample.invoke(&#39;clear&#39;);"
               id="clear" name="clear" value="clear" />
    &lt;/body>
&lt;/html>

```クライアント側の処理は次のような感じ。［クライアント］ボタンクリックで sample ハブの Add/Clear を呼ぶ<br/>
→ ［サーバー］sample ハブが接続中のクライアントへ Echo() をブロードキャスト<br/>
→ ［すべてのクライアント］#value が更新されるというカラクリ。

</div>
<div class="section">
    ### 結果
    {{< figure src="/images/20120831025740.png"  >}}3つブラウザーを起動し、そのうち1つのブラウザーでボタンを押すと、ほかも全部いっぺんに更新される！　これはちょっと楽しいな。

<ul>
<li><a href="http://shiba-yan.hatenablog.jp/entry/20120823/1345724524">SignalR 0.5.3 で変わった JavaScript クライアント - しばやん雑記</a></li>
<li><a href="https://blog.daruyanagi.jp/entry/2012/07/04/081647">SignalR のデモがちょっとかっこいい - だるろぐ</a></li>
</ul>
</div>

