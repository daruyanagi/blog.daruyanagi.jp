
+++
date = "2017-06-08 19:50:54 +0000 UTC"
draft = false
title = "Tonjiru v1.2.0 ＋ WPF での起動オプション、ジャンプリスト、トースト"
tags = ["告知","Tonjiru","WPF"]

+++


{{< figure src="/images/20170608192727.png"  >}}

br/>


<ul>
<li>起動オプションの追加（/g で GUI 付きの起動）</li>
<li>ジャンプリストへの対応（GUI 付きの起動を追加）</li>
<li>ウィンドウ情報のクリップボードコピー（JSON 形式）</li>
<li>ウィンドウ情報のファイル保存（JSON 形式）</li>
<li>通知機能</li>
<li>安定性の向上</li>
</ul>
<div class="github-card" data-user="daruyanagi/Tonjiru/releases/tag" data-repo="v1.2.0" data-width="400" data-height="" data-theme="default"></div

>
<script src="https://cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
<br/>


<div class="section">
    ### WPF と起動オプション
    起動時に［Shift］キーが押されていたら GUI を起動するという挙動は

<ul>
<li>App.xaml の StartupUri を削除</li>
<li>App.Startup でキーの押し下げ確認と MainWindow の自前生成</li>
</ul>という感じで実現していたんだけど、起動オプションを付けたら破綻したので、

<ul>
<li>App.xaml の StartupUri を元に戻す</li>
<li>App.xaml のビルドアクションを Page にして、main 関数を自分で書く</li>
</ul>という感じに変えた。
```cs
[System.STAThreadAttribute()]
public static void Main()
{
    var args = Environment.GetCommandLineArgs();

    if (args.Contains("/g") || (Control.ModifierKeys &amp; Keys.Shift) == Keys.Shift)
    {
        var app = new Tonjiru.App();
        app.InitializeComponent();
        app.Run();
    }
    else // UI less mode
    {
        CloseAllWindowsAndExit();
    }
}

```/h スイッチで CUI ヘルプを出そうかなーと思ったけど、そっちはちょっと面倒くさいのでやめた。AttachConsole() などを使えば行けるのだけど、ちょっと挙動が変。ちゃんとやろうとすると CUI と GUI で EXE を分けないといけないみたいだが、そこまでやる気はないかな。

</div>
<div class="section">
    ### ジャンプリスト
    起動オプションを付けた副産物として、ジャンプリストへの対応が簡単になった。App.xaml に以下のように記述。
```xml
x:Class="Tonjiru.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:Tonjiru"
             StartupUri="Views\MainWindow.xaml">
    .Resources>
         
    .Resources>

    .JumpList>
        <jumplist></jumplist>
            Title="Launch with GUI"
                Description="Launch with GUI" 
                Arguments="/g" />
        
    .JumpList>


```ジャンプリストは最近忘れられてる気がするけど、割かし便利だと思う。対応アプリが増えるといいな。なお、ジャンプリストから起動するとワーキングディレクトリが System フォルダーになった気がする。設定ファイルなどをロードするとき、パス検索をいい加減にしていると痛い目にあう（あった）。

</div>
<div class="section">
    ### ValueTupple と DataContractJsonSerializer
    ウィンドウ情報の保存は手抜きで DataContractJsonSerializer を使ったんだけど、Model をそのままシリアライズするとサイズがすごく大きくなってしまった。そこで情報を間引いたんだが、ここでタプルが使えるのではないかと気づいた。
```cs
list.Select(_ => (title: _.Title, process: _.ProcessName)); // これをシリアライズ

```試しにこれを
```cs
DataContractJsonSerializer(typeof(ValueTupple&lt;string, string>));

DataContractJsonSerializer(typeof((string title, string process)));

```みたいに使ってみたところ――とりあえずコンパイルは通り、普通に使えた。けれど、出力される JSON がどっちも
```
[{ "Item1": "hoge", "Item2": "fuga" }]
```みたいな感じになる（ほんとは Item1 のところが title や process になってほしいよね）ので、これを使うのはあきらめた。JSON.net のシリアライズだったら対応していた（or 対応してくれる）かもしれない？

</div>
<div class="section">
    ### 通知
    WPF でトーストを出そうと思うと WindowsRuntime を使わなくちゃーってなりがちだけど、ただ出したいだけであれば NotifyIcon で ShowBalloonTip() するのが楽でいい。Windows 7 だとバルーンだが、Windows 10 ではトーストになる。
```cs
using (var notify_icon = new System.Windows.Forms.NotifyIcon())
{
    notify_icon.Icon = System.Drawing.Icon.ExtractAssociatedIcon(System.Reflection.Assembly.GetEntryAssembly().Location);
    notify_icon.Visible = true;

    notify_icon.BalloonTipTitle = System.Reflection.Assembly.GetExecutingAssembly().GetName().Name;
    notify_icon.BalloonTipText = message;
    notify_icon.ShowBalloonTip(3000);
}

```簡単だね！

{{< figure src="/images/20170608194803.png"  >}}

イントは Visible を true にしておくこと（じゃないとトーストが出てこない）、最後に Visible を False にするか Dispose() すること（でないとトレイにアイコンがゾンビ）ぐらい。

</div>

