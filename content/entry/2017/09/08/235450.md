
+++
date = "2017-09-08 23:54:50 +0000 UTC"
draft = false
title = "Razor Pages：PhantomJS で動的サイトをスクレイピングする"
tags = ["ASP.NET Core Razor Page"]

+++


{{< figure src="/images/20170908233127.png"  >}}

Windows 10 version 1703 の最新ビルドの番号をテキトーに得るサンプル）静的サイトのスクレイピングは HTML をダウンロードしてごちゃごちゃっとやればいいけど、動的サイトの場合はブラウザーで JavaScript の評価をしたあとの HTML（DOM ツリーっていうの？）がほしい。というわけで、ヘッドレスブラウザー「PhantomJS」でアクセス → 評価するサンプルを Razor Pages で作ってみた。ソリューションはこんな構成になった。

{{< figure src="/images/20170908233703.png"  >}}

SP.NET Core＋Razor Pagesの導入方法は以下のページを参照のこと（別にこの通りにやる必要はないけど）。[空のアプリケーションから ASP.NET Core Razor Page を始める - だるろぐ](http://blog.daruyanagi.jp/entry/2017/08/15/043634)<br/>


<div class="section">
    ### 基本的な流れ
    PhantomJS.exe にスクリプトと Uri とセレクターを渡し、標準出力を介して結果（JSON）を得る。標準出力には PhantomJS が吐くエラーが混じることがあるので、適当な正規表現で除去しておく。

</div>
<div class="section">
    ### Index.cshtml
    コードビハインド？　MVVM じゃない方の ViewModel？　なんて言っていいのかは知らんけど（変な言葉遣いしたらその手のケーサツが来そうだし）、Index.cshtml の裏はこんな感じ。
```cs
// index.cshtml.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using System.Diagnostics;
using System.IO;

namespace WebApplication5.Pages
{
    public class IndexModel : PageModel
    {
        [BindProperty]
        public Uri Target { get; set; }

        [BindProperty]
        public string Selector { get; set; }

        [BindProperty]
        public Models.ScrapingResult Result { get; private set; }

        public IActionResult OnPost(string message)
        {
            if (!ModelState.IsValid) return Page();

            var root_dir = Hosting.Environment.ContentRootPath;
            var work_dir = System.IO.Path.Combine(root_dir, "Tools");
            var script_name = "scrape.js";

            var info = new ProcessStartInfo()
            {
                Arguments = $@"""{script_name}"" ""{Target}"" ""{Selector}""",
                FileName = Path.Combine(work_dir, "phantomjs.exe"),
                CreateNoWindow = true,
                RedirectStandardOutput = true,
                StandardOutputEncoding = System.Text.Encoding.UTF8,
                UseShellExecute = false,
                WorkingDirectory = work_dir,
            };

            using (var process = new Process() { StartInfo = info, })
            {
                var output = string.Empty;

                process.OutputDataReceived += (s, a) => { output += a.Data; Debug.WriteLine(a.Data); };

                process.Start();
                process.BeginOutputReadLine();
                process.WaitForExit();

                // エラー出力をちょん切る
                var r = new System.Text.RegularExpressions.Regex("{.+}");
                output = r.Match(output).Value;

                Result = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Models.ScrapingResult>(output);
            }

            return Page();
        }
    }
}

```ユーザーインターフェイス（Index.cshtml）はこんな感じ。まだ慣れてないのでこれいいのかよくわかんないけど、タグヘルパーってやつでバインディングできるんだなー。便利ンゴ。
```cs
// Index.cshtml
@page
@model WebApplication5.Pages.IndexModel
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers

&lt;html>
&lt;body>
    &lt;style>
        *, input { font-family: Meiryo; margin: 8px; }
        pre { background-color: linen; width: 480px; overflow: scroll; }
    &lt;/style>
    &lt;pre>&lt;code>
        @Model.Result?.Text
    &lt;/code>&lt;/pre>
    &lt;div asp-validation-summary="All">&lt;/div>
    &lt;form method="POST">
        &lt;div>Target Uri: &lt;input asp-for="Target" />&lt;/div>
        &lt;div>Selector: &lt;input asp-for="Selector" />&lt;/div>
        &lt;input type="submit" />
    &lt;/form>
&lt;/body>
&lt;/html>

```
</div>
<div class="section">
    ### モデル
    スクレイピングの結果を表すモデル（？）クラスはこんな感じ。スクリプトが返す JSON の形式が固まるまでは dynamic にしちゃうと楽だね。
```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace WebApplication5.Models
{

    public class ScrapingResult
    {
        [JsonProperty("uri")]
        public string Url { get; set; }

        //[JsonProperty("selector")]
        public string Selector { get; set; }

        public string Status { get; set; }

        public string Text { get; set; }
    }
}

```<code>[JsonProperty("uri")]</code> は要らんのか？　コメントアウトしても動いたから、命名規約ベースでよしなにしてくれるのかもしれない。

</div>
<div class="section">
    ### PhantomJS スクリプト
    PhantomJS に渡したスクリプトの中身はこんな感じ。
```javascript
var page = require(&#39;webpage&#39;).create();
var system = require(&#39;system&#39;);
var url = system.args[1];
var selector = system.args[2];

page.open(url, function (status) {
    var text = null;
    if (status === &#39;success&#39;) {
        text = page.evaluate(function (selector) {
            var element = document.body.querySelector(selector);
            if (element == null) return null;
            return element.innerHTML;
        }, selector);
    }
    console.log(JSON.stringify({ url: url, selector: selector, status: status, text: text, }));
    phantom.exit();
});

```ちょっと悩んだのは page.evaluate() がサンドボックスになっていたこと。プリミティブ型じゃないとやり取りできないのかな。page.evaluate() に変数を渡す方法も悩んだけど、だいたいこれでイケそう<a href="#f-54d78508" name="fn-54d78508" title="JavaScript のスコープとか、基本があんまりわかってないのですごく悩んだ">*1</a>。ほんとは引数チェックしたり、エラートラップして終了コードを渡したりした方がいいよね。まぁ、サンプルなのでいろいろ適当でいい気がする。で、ここまで完成させたあとに昔ブックマークしたページのことを思い出した。[C#でモダンにスクレイピングするならAngleSharp - Qiita](http://qiita.com/matarillo/items/a92e7efbfd2fdec62595)JavaScript の評価もできるなら、こっちを使った方がよかったかもしれない。

</div><div class="footnote">
<a href="#fn-54d78508" name="f-54d78508" class="footnote-number">*1</a><span class="footnote-delimiter">:</span><span class="footnote-text">JavaScript のスコープとか、基本があんまりわかってないのですごく悩んだ</span>
</div>

