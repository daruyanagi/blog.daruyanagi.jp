
+++
date = "2012-08-08 03:57:45 +0000 UTC"
draft = false
title = "WebMatrix + ASP.NET Web Pages でキレイにコーディングしたい（2）"
tags = ["ASP.net Web Pages","WebMatrix"]

+++
>
        あと、 @RenderPage("_Footer.cshtml") は @RenderFooter() などと記述できるとカッコいいな。「フッターはテーマフォルダ直下の“_Footer.cshtml”に書く」。なるべく規約ベースで。これも簡単にできそうだ。

        WebMatrix + ASP.NET Web Pages でキレイにコーディングしたい - だるろぐ
    
これをやってみた。なんていうか、“_Footer.cshtml”なんて固定値、あんまりよく目にするところに書いておきたくない。{{< figure src="/images/20120808030122.png"  >}}<br/>


<div class="section">
    ### 拡張メソッド
    まずは拡張メソッドを試してみた。 WebPage クラスがあたかも最初から RenderFooter() をもっていたかのように見せかけるのが目的。“App_Code”フォルダを掘って、そのなかに C# クラスファイル（.cs）を作成する。 RenderBody() のシグネチャを参考にこういうのを作ってみた。
```cs
using System.Web.WebPages;

static public class WebPageExtensions
{
    static public HelperResult RenderFooter(
        this WebPage target, params object[] data)
    {
        return target.RenderPage("_Footer.cshtml", data);
    }
}

```すると、 cshtml ファイルで @this.RenderFooter() という感じで呼べる。
```html
:
:
        &lt;div id="site-content">
            &lt;article id="site-body">
@RenderBody()
            &lt;/article>
            &lt;aside id="site-sidebar">
@RenderPage("_SideBar.cshtml") <!-- 古い書き方 -->
            &lt;/aside>
        &lt;/div>

        &lt;footer id="site-footer">
@this.RenderFooter() <!-- 新しい書き方 -->
        &lt;/footer>
    &lt;/body>
&lt;/html>

```そうなんだ、** this が要るんだ**。 @RenderBody() みたいに this を使わずに呼びたかったけれど、これはどうしようもないっぽい。

</div>
<div class="section">
    ### Func<helperresult></helperresult>
    次に考えたのは、 Func&lt;HelperResult> を使うこと。最初の @{……} セクションで RenderFooter を定義しておけば、 this なしの @RenderFooter() で使えるはず。
```cs
&lt;!DOCTYPE html>

@{
    App.Title = App.Title ?? "Untitled Application";
    App.Language = App.Language ?? "en";
    App.Encoding = App.Encoding ?? "utf-8";
    Page.Title = Page.Title ?? "Untitled Page";

    Func&lt;HelperResult> RenderFooter =
        () => RenderPage("_Footer.cshtml");
}

&lt;html lang="@App.Language">
    &lt;head>
:
:

```cshtml ファイルはこんなかんじになる。
```html
:
:
        &lt;div id="site-content">
            &lt;article id="site-body">
@RenderBody()
            &lt;/article>
            &lt;aside id="site-sidebar">
@RenderPage("_SideBar.cshtml") <!-- 古い書き方 -->
            &lt;/aside>
        &lt;/div>

        &lt;footer id="site-footer">
@RenderFooter() <!-- 新しい書き方 -->
        &lt;/footer>
    &lt;/body>
&lt;/html>

```目的は達成したけれど、これはこれでどうなんだろう。とりあえず今のところ単純なラムダ式でなんとかなっているけれど、たとえばRenderFooter でエラー処理を追加する場合（“_Footer.cshtml”がない場合がありえる）を考えると、「レイアウトファイルを簡潔にしたい」という目的からはだいぶ外れてくる。RenderFooter をページの初期化に使う“_PageStart.cshtml”へ逃がそうかと思ったけれど、それもダメそうだし。結局、“_PageStart.cshtml”へ退避できるものだけ退避させて、あとはこんな感じにした。
```cs
&lt;!DOCTYPE html>

@{
    Func&lt;HelperResult> RenderHeader =
        () => RenderPage("_Header.cshtml");
    Func&lt;HelperResult> RenderNavigation =
        () => RenderPage("_Navigation.cshtml");
    Func&lt;HelperResult> RenderSideBar =
        () => RenderPage("_SideBar.cshtml");
    Func&lt;HelperResult> RenderFooter =
        () => RenderPage("_Footer.cshtml");
}

&lt;html lang="@App.Language">
    &lt;head>
:
:

```マジックワードを一元管理できるだけでも、まぁ、いいかな。ちなみに @{……} を DOCTYPE 宣言のあとに書くように変えたのは、 XML ドキュメントを返すときとの統一性を考えて。むかし、 DOCTYPE 宣言の前に @{……} を書いて無駄な改行が入ってしまい、ちゃんと解釈してもらえなかったことがあったので。

</div>
<div class="section">
    ### おまけ
    調べている途中でみつけたのだけれど、これおもしろいな。
```cs
@{
    Func&lt;dynamic, object> b = @&lt;strong>@item&lt;/strong>;
}
&lt;span>This sentence is @b("In Bold").&lt;/span>

```手元で試したらちゃんと動いたし。

    >
        Note that the delegate that’s generated is a Func. Also, the @item parameter is a special magic parameter. These delegates are only allowed one such parameter, but the template can call into that parameter as many times as it needs.

        Templated Razor Delegates | You’ve Been Haacked
    
なんでこうなるのかイマイチよくわからんけど……。 @ って結局なんなんだ（＠ｗ＠！

<ul>
<li><a href="http://shiba-yan.hatenablog.jp/entry/20110423/1303562559">Templated Razor Delegates が面白い - しばやん雑記</a></li>
</ul>
</div>

