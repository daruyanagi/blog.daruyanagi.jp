
+++
date = "2016-09-19 22:44:30 +0000 UTC"
draft = false
title = "UWP：はてなの oAuth 認証"
tags = ["UWP","はてな","C#"]

+++


{{< figure src="/images/20160919220838.png"  >}}

ログラミングの秋……なのかな？　最近、またプログラミングをちょろちょろとやっています。今回は、UWP。一つ新しいのができたのでストアに提出して、今はむかし作りかけて放置中のはてブをつけるアプリを完成させようと四苦八苦してる途中。実はこのアプリ、ほぼ完成していて、Windows 10 Mobile ではてブみたりはてブつけるのに使っているのだけど、セットアップに AtomPub の APIキー を使うタイプなんだよね。自分で使う分にはこれでもいいんだけど、ちょっとダサいので oAuth でやりたかった。

<div class="section">
    ### AsyncOAuth を導入する
    さて、oAuth はトークンのやり取りとかハッシュとかヘッダーの生成とか、いろいろややこしい処理がある。自分でも組んでみたけど、どこかちょっと間違ってるみたいで、なかなか認証が通らない。というわけで、ライブラリさまのお力を借りた。いろいろ探してみたんだけど、AsyncOAuth が一番気に入ったかも。

<ul>
<li><a href="http://neue.cc/2013/02/27_398.html">neue cc - AsyncOAuth - C#用の全プラットフォーム対応の非同期OAuthライブラリ</a></li>
</ul>UWP プロジェクトに NuGet でインストールできなかったんだけど、手動で加えたら問題なく動いた。もうメンテナンスされていないのかもしれないけど、せっかくいいものなので UWP でもサクッと使えるようにしてほしいな（賛同してくれるヒトは、みんなで のいえっち にサイレントプレッシャーをかけよう！）。<iframe src="//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fneuecc%2FAsyncOAuth%2Fissues%2F23" title="Cannot add nuget to UWP project · Issue #23 · neuecc/AsyncOAuth" class="embed-card embed-webcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;"></iframe>AsyncOAuth にはコンソールアプリだけど はてな 認証のサンプルもついてる。これを UWP 向けにチョロチョロと改造すればおっけ。
```cs
var authorizer = new OAuthAuthorizer(ConsumerKey, ConsumerSecret);
var callbackUri = "http://localhost/";

var requestTokenResponse = await authorizer.GetRequestToken(
    "https://www.hatena.com/oauth/initiate",
    new[]
    { 
        new KeyValuePair&lt;string, string>(
            "oauth_callback",
            callbackUri
        )
    },
    new FormUrlEncodedContent(new[] {
        new KeyValuePair&lt;string, string>(
            "scope", 
            "read_public,write_public,read_private,write_private"
        )
    }));

var requestToken = requestTokenResponse.Token;

var authorizeUrl = authorizer.BuildAuthorizeUrl(
    "https://www.hatena.ne.jp/touch/oauth/authorize", 
    requestToken);

```たとえば、リクエストトークンをとるまでのところはこんな感じ。めんどくさいところは全部やってくれるので楽ちんだー。callbackUri を“oob”にしたら PIN を使った認証になる。WebAuthenticationBroker.GetCurrentApplicationCallbackUri() で取得した URL は はてな では使えないみたいなので、今回は“<a href="http://localhost/">http://localhost/</a>”をセットしておく（これはあとで認証するときに必要になる）。

</div>
<div class="section">
    ### WebAuthenticationBroker を使って認証する
    

{{< figure src="/images/20160919223009.png"  >}}

は Web へアクセスして認証。UWP には WebAuthenticationBroker っていうダイアログを出す仕組み（それだけじゃないけど）が用意されているので、それを使うといい感じ。
```cs
// さっき取得したリクエストトークンを使って認証 URI を取得
var authorizeUrl = authorizer.BuildAuthorizeUrl(
    "https://www.hatena.ne.jp/touch/oauth/authorize",
     requestToken);

// ダイアログを開いて結果を取得
var webAuthenticationResult = await WebAuthenticationBroker
    .AuthenticateAsync(
        WebAuthenticationOptions.None,
        new Uri(authorizeUrl), new Uri(callbackUri)
    );

// 結果をみていろいろ分岐処理
switch (webAuthenticationResult.ResponseStatus)
{
    case WebAuthenticationStatus.Success:
        try
        {
            // http://localhost?...=...&amp;...=... っていうのが
            // 返るのでテキトーに千切って verifier だけ取得
            var verifier = webAuthenticationResult.ResponseData
                .Split(&#39;?&#39;).Last()
                .Split(&#39;&amp;&#39;).Last()
                .Split(&#39;=&#39;).Last();
            // リクエストトークンと verifier で
            // アクセストークンをゲット
            // これでいろいろし放題だ！
            var accessTokenTokenResponse = await authorizer
                .GetAccessToken(
                    "https://www.hatena.com/oauth/token",
                    requestToken, verifier);

            AccessToken = accessTokenTokenResponse.Token;

            result = true;
        }
        catch (Exception exception)
        {
            // エラー処理するんやで
        }
        break;

    case WebAuthenticationStatus.ErrorHttp:
    case WebAuthenticationStatus.UserCancel:
    default:
        break;
}

```
</div>
<div class="section">
    ### ユーザー情報を取得
    

{{< figure src="/images/20160919223808.png"  >}}

とは OAuthUtility.CreateOAuthClient() でクライアントを取得してごにょごにょするだけ。このクライアントは AsyncOAuth が HttpClient にフィルター（？）をかましているだけなので、HttpClient みたいに GetAsync() とかできる。
```cs
var client = OAuthUtility.CreateOAuthClient(
    ConsumerKey, ConsumerSecret, AccessToken
);

var json = await client.GetStringAsync(
    "http://n.hatena.com/applications/my.json"
);

```これでディスプレイネームやプロフィールイメージなんかが取得できるので、テキトーにバインディングしてあげればおっけ。楽ちんでいいわー。

</div>

